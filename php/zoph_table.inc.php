<?php

/*
 * A generic table class.  Is is meant to be subclassed by particular
 * table classes.  A table is represented by a name, an array of
 * primary keys, and an array mapping field names to values.
 *
 * This file is part of Zoph.
 *
 * Zoph is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * Zoph is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with Zoph; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

class zoph_table {

    var $table_name;
    var $primary_keys;
    var $fields;
    var $not_null; // Fields that may not be empty

    /*
     * This construnctor should be called from the constructor
     * of a subclass.
     */
    function zoph_table($table_name, $primary_keys, $not_null) {
        $this->table_name = DB_PREFIX . $table_name;
        $this->primary_keys = $primary_keys;
        $this->not_null = $not_null;
        $this->fields = array();
    }

    /*
     * Gets a field.
     */
    function get($name) {
        log::msg("<b>GET</b> " . $name, log::DEBUG, log::VARS);  
        log::msg("<pre>" . var_export($this->fields, true) . "</pre>", log::MOREDEBUG, log::VARS);
        if (isset($this->fields[$name])) {
            return $this->fields[$name];
        } else {
            return "";
        }
    }

    /*
     * Sets a field.
     */
    function set($name, $value) {
        $this->fields[$name] = $value;
    }

    /*
     * Sets fields from the given array.  Can be used to set vars
     * directly from a GET or POST.
     */
    function set_fields($vars, $prefix = null, $suffix = null, $null=true) {

        reset($vars);
        while (list($key, $val) = each($vars)) {

            log::msg("<b>" . $key . "</b> = " . $val, log::DEBUG, log::VARS);

            // ignore empty keys or values unless the field must be set.

            if ($null) {
                if ((!in_array($key, $this->not_null)) && (empty($key) )) { continue; }
            } else {
                if ((!in_array($key, $this->not_null)) && (empty($key) || $val == "")) { continue; }
            }


            if ($prefix) {
                if (strpos($key, $prefix) === 0) {
                    $key = substr($key, strlen($prefix));
                }
                else {
                    continue;
                }
            }
            else if ($key[0] == '_') {
                // a leading uderscore signals a non-database field
                continue;
            }

            if ($suffix) {
                $pos = strpos($key, $suffix);
                if (($pos > 0) && (preg_match("/".$suffix."$/", $key))) {
                    $key = substr($key, 0, $pos);
                }
                else {
                    continue;
                }
            }

            // something in ALL CAPS is probably PHP or HTML related
            if (strtoupper($key) == $key) { continue; }

            $this->fields[$key] = stripslashes($val);

        }

    }

    /*
     * Checks to see if the given field is listed as a primary key.
     */
    function is_key($name, $keys = null) {
        if (!$keys) { $keys = $this->primary_keys; }
        return in_array($name, $keys);
    }

    /*
     * Looks up a record.
     */
    function lookup($sql = null) {

        if (!$this->table_name || !$this->primary_keys || !$this->fields) {
            log::msg("Missing data", log::ERROR, log::GENERAL);
            return;
        }

        if (!$sql) {
            $constraint = $this->create_constraints($this->primary_keys);

            if (!$constraint) {
                log::msg("No constraint found", log::NOTIFY, log::GENERAL);
                return;
            }

            $sql = "select * from $this->table_name where $constraint";
        }

        $result = query($sql, "Lookup failed:");
        if (num_rows($result) == 1) {
            $row = fetch_assoc($result);

            $this->fields = array();

            //$this->set_fields($row);
            $this->fields = array_merge($this->fields, $row);

            return 1;
        }

        return 0;

    }

    /*
     * Inserts a record.  The default behavior is to ignore the
     * primary key field(s) with the assumption that these will
     * be generated by the db (auto_increment).  Passing a non null
     * parameter causes these fields to be manually inserted.
     */
    function insert($keep_key = null) {

        if (!$this->table_name || !$this->fields) {
            log::msg("Missing data", log::ERROR, log::GENERAL);
            return;
        }
        $names=null;
        $values=null;
        while (list($name, $value) = each($this->fields)) {
            if ($this->primary_keys && !$keep_key && $this->is_key($name)) {
                continue;
            }

            if (!empty($names)) {
                $names .= ", ";
                $values .= ", ";
            } 

            $names .= $name;

            if ($name == "password") {
                $values .= "password('" . escape_string($value) . "')";
            }
            else if ($value == "now()") {
                /* Lastnotify is normaly set to "now()" and should not be escaped */
                $values .=  $value ;
            } else if ($value =="" && in_array($name, $this->not_null)) {
	    	    die("<p class='error'><b>$name</b> may not be empty</p>");
	        } else if ($value !== "") {
                $values .= "'" . escape_string($value) . "'";
            } else {
                $values .= "null";
            }

        }

        $sql = "insert into $this->table_name ($names) values ($values)";

        query($sql, "Insert failed:");

        $id = insert_id();

        if ($this->primary_keys && count($this->primary_keys) == 1) {
            $this->fields[$this->primary_keys[0]] = $id;
        }

        return $id;

    }

    /*
     * Deletes a record.  If extra tables are specified, entries from
     * those tables this match the keys are removed as well.
     */
    function delete($keys = null, $extra_tables = null) {
        if (!$keys) { $keys = $this->primary_keys; }

        if (!$this->table_name || !$keys || !$this->fields) {
            log::msg("Missing data", log::ERROR, log::GENERAL);
            return;
        }

        $constraints = $this->create_constraints($keys);

        if (!$constraints) {
            log::msg("No constraint found", log::NOTIFY, log::GENERAL);
            return;
        }

        $sql = "delete from $this->table_name where $constraints";

        query($sql, "Delete failed:");

        if ($extra_tables) {
            foreach ($extra_tables as $table) {
                $table = DB_PREFIX . $table;
                $sql = "delete from $table where $constraints";
                query($sql, "Delete from $table failed:");
            }
        }
    }

    /*
     * Updates a record.
     */
    function update($keys = null) {
        if (!$keys) { $keys = $this->primary_keys; }

        if (!$this->table_name || !$keys || !$this->fields) {
            log::msg("Missing data", log::ERROR, log::GENERAL);
            return;
        }

        $constraints = $this->create_constraints($keys);

        if (!$constraints) {
            log::msg("No constraint found", log::NOTIFY, log::GENERAL);
            return;
        }
        reset($this->fields);
        $values=null;
        $names=null;
        while (list($name, $value) = each($this->fields)) {
            if ($this->is_key($name, $keys)) { continue; }

            if (!empty($values)) { $values .= ", "; }
            
            if (substr($name,0,7)=="parent_") {
                $children=array();
                $this->get_branch_id_array($children);
                if(in_array($value, $children)) {
                    die("You cannot set the parent to a child of the current selection!");
                } 
            }

            if ($name == "password") {
                $values .= "$name = password('" . escape_string($value) . "')";
            } else if ($value == "now()" ) {
                $values .= "$name = " . $value . "";
            } else if ($value == "" && in_array($name, $this->not_null)) {
	    	    die("<p class='error'><b>$name</b> may not be empty</p>");
	        } else if ($value !== "" && !is_null($value)) {
                $values .= "$name = '" . escape_string($value) . "'";
            } else {
                $values .= "$name = null";
            }
        }

        if (!$values) { return; }

        $sql = "update $this->table_name set $values where $constraints";

        query($sql, "Update failed:");

    }

    /*
     * Creates a constraint clause based on the given keys
     */
    function create_constraints($keys) {
        $constraints=null;
        foreach ($keys as $key) {
            $value = $this->fields[$key];
            if (!$value) { continue; }
            if (!empty($constraints)) { $constraints .= " and "; }
            $constraints .= "$key = '" . escape_string($value) . "'";
        }
        return $constraints;
    }

    /*
     * Creates an alphabetized array of field names and values.
     */
    function get_display_array() {
        if (!$this->fields) { return; }

        $keys = array_keys($this->fields);
        sort($keys);
        reset($keys);
        foreach ($keys as $k) {
            if ($this->is_key($k)) { continue; }
            $title = make_title($k);
            $da[$title] = $this->fields[$k];
        }

        return $da;
    }

    /*
     * Creates an alphabetized array of field names and text input blocks.
     */
    function get_edit_array() {
        if (!$this->fields) { return; }

        $field_lengths = get_field_lengths($this->table_name);

        $keys = array_keys($field_lengths);
        sort($keys);
        reset($keys);
        foreach ($keys as $k) {
            if ($this->is_key($k)) { continue; }
            $title = make_title($k);

            $len = $field_lengths[$k];
            $size = min($len, 20);

            $ea[$title] = create_text_input($k, $this->fields[$k], $size, $len);
        }

        return $ea;
    }

    function get_mapping_js($user,$icon,$edit=false) {
        $marker=true;
        $lat=$this->get("lat");
        $lon=$this->get("lon");
        $zoom=$this->get("mapzoom");
        if(!$lat && !$lon) { $marker=false; }
        if(!$lat) { $lat=0; }
        if(!$lon) { $lon=0; }
        if(!$zoom) { $zoom=2; }
        $js="<script type='text/javascript'>\n" .
            "  var center=new mxn.LatLonPoint(" .
                $lat . "," .
                $lon . ");\n" .
            "  var zoomlevel=" . $zoom . ";\n" .
            "  mapstraction.setCenterAndZoom(center,zoomlevel);\n";
         if ($marker ) {
            $js.="  zMaps.createMarker(" . $lat . "," . $lon . ",'" . $icon . "',null, null);\n";
         }
         if ($edit) {
            $js.="  zMaps.setUpdateHandlers();\n";
         }
            $js.="</script>";
        return $js;
    }

    function get_marker($user, $icon) {
        $lat=$this->get("lat");
        $lon=$this->get("lon");
        if($lat && $lon) {
            $quicklook=$this->get_quicklook($user);
            return "  zMaps.createMarker(" . $lat . "," . $lon . ", '" . $icon .
                    "','" .  e($title) . "','" . 
                    $quicklook . "');\n";
        } else {
            return null;
        }
    }


}

/*
 * Gets the total count of records in the table for the given class.
 */
function get_count($class) {

    if (class_exists($class)) {
        $obj = new $class;
        $table = $obj->table_name;
    }
    else {
        $table = DB_PREFIX . $class;
    }

    $sql = "select count(*) from $table";

    return get_count_from_query($sql);
}


/*
 * Executes the given query and returns the result.
 */
function get_count_from_query($sql) {
    $result = query($sql, "Unable to get count");
    return result($result, 0, 0);
}

/*
 * Gets an array of the records for a table by doing a * "select *"
 * and storing the results in classes of the given type.
 */
function get_records($class, $order = null, $constraints = null,
    $conj = "and", $ops = null) {

    $obj = new $class;
    $sql = "select * from $obj->table_name";
    if ($constraints) {
        while (list($name, $value) = each($constraints)) {
            if ($constraint_string) {
                $constraint_string .= " $conj ";
            }
            else {
                $constraint_string .=  " where ";
            }

            $op = "=";
            if ($ops && $ops["$name"]) {
                $op = $ops["$name"];
            }

            $n = strpos($name, "#");
            if ($n > 1) {
                $name = substr($name, 0, $n);
            }

            if ($value == "null" || $value == "''") {
                // ok
            }
            else {
                $value = "'" . escape_string($value) . "'";
            }

            $constraint_string .= "$name $op $value";
        }
        $sql .= $constraint_string;
    }

    if ($order) {
        $sql .= " order by $order";
    }
    return get_records_from_query($class, $sql);
}

/*
 * Stores the results the the given query in an array of objects of
 * this given type.
 */
function get_records_from_query($class, $sql, $min = 0, $num = 0) {

    $result = query($sql, "Unable to get records");

    if ($min) {
        data_seek($result, $min);
    }

    if ($num) {
        $limit = true;
    } else {
        $limit = false;
    }

    $objs = array();
    if ($class != null) {
        while ((!$limit || $num-- > 0) && $row = fetch_assoc($result)) {
            $obj = new $class;
            $obj->set_fields($row);
            $objs[] = $obj;
        }
    } else {
        // use to grab ids, for example
        while ((!$limit || $num-- > 0) && $row = fetch_row($result)) {
            $objs[] = $row[0];
        }
    }

    free_result($result);
    return $objs;
}

/*
 * Executes a query and returns an array in which each record's
 * link is mapped to its count (dirived by a group by clause).
 */
function get_popular_results($class, $query) {
    $records = get_records_from_query($class, $query);
    foreach ($records as $rec) {
        $pop_array[$rec->get_link()] = $rec->get("count");
    }
    return $pop_array;
}

/*
 * Creates an array to be used in the create_pulldown methods.  The
 * values of the fields in the name_fields parameter are concatentated
 * together to construnct the titles of the selections.
 */
function create_select_array($records, $name_fields) {
    if (!$records || !$name_fields) { return; }

    foreach ($records as $rec) {
        // this only makes sense when there is one key
        $id = $rec->get($rec->primary_keys[0]);

        $name = "";
        foreach ($name_fields as $n) {
            if ($name) { $name .= " "; }
            $name .= $rec->get($n);
        }

        $sa[$id] = $name;
    }

    return $sa;
}

/*
 * Creates an object of the given class and returns the output of
 * its get_link() method.
 */
function get_link($class, $id) {
    if (!$class || !$id) { return ""; }
    $obj = new $class($id);
    $obj->lookup();
    return $obj->get_link();
}

/**
 * Create a link list
 * Creates a comma separated list of links from the given records.
 * The class of the records must implement the get_link function.
 */
function create_link_list($records) {
    $links = "";
    if ($records) {
        foreach ($records as $rec) {
            if ($links) { $links .= ", "; }
            $links .= $rec->get_link();
        }
    }

    return $links;
}

/**
 * Get XML from a database table
 * This is a wrapper around several objects which will call a method from 
 * those objects
 * @param string Name of the class to be used
 * @param string Search string
 * @param user Only return records that can be seen by this user
 * @todo This should be replaced by a proper OO construction
 */
function get_xml($class, $search,$user=null) {
    $search=strtolower($search);
    if($class=="location" || $class=="home" || $class=="work") {
        $class="place";
    } else if ($class=="photographer") {
        $class="person";
        $subclass="photographer";
    } else if ($class=="father" || $class=="mother" || $class=="spouse") {
        $class="person";
    }


    if($class=="person") {
        $tree=false;
    } else {
        $tree=true;
    }

    if($class=="timezone") {
        $tz=new TimeZone("UTC");
        return $tz->get_xml($search);
    } else if($class=="import_progress") {
        $import=new WebImport($search);
        return $import->get_xml();
    } else if($class=="import_thumbs") {
        return WebImport::getThumbsXML();
    } else if (class_exists($class)) {
        $obj=new $class;
        $rootname=$obj->xml_rootname();
        $nodename=$obj->xml_nodename();
        $idname=$obj->primary_keys[0];

        $xml = new DOMDocument('1.0','UTF-8');
        $rootnode=$xml->createElement($obj->xml_rootname());
        $newchild=$xml->createElement($obj->xml_nodename());
        $key=$xml->createElement("key");
        $title=$xml->createElement("title");
        $key->appendChild($xml->createTextNode("null"));
        $title->appendChild($xml->createTextNode("&nbsp;"));
        $newchild->appendChild($key);
        $newchild->appendChild($title);
        $rootnode->appendChild($newchild);

        if ($tree) {
            $obj = get_root($class);
            $obj->lookup();
            $tree=$obj->get_xml_tree($xml, $search, $user);
            $rootnode->appendChild($tree);
        } else {
            if($class=="person") {
                if($search=="") {
                    $search=null;
                }
                if($user->is_admin()) {
                   $records=get_all_people($user,$search, true);
                } else {
                    if($subclass=="photographer") {
                        $records=get_photographers($user,$search,true);
                    } else {
                        $records=get_photographed_people($user,$search,true);
                    }
                }
            } else {
                $records=get_records($class, $order, $constraints, $conj, $ops);
            } 
           
            foreach($records as $record) {
                $newchild=$xml->createElement($nodename);
                $key=$xml->createElement("key");
                $title=$xml->createElement("title");
                $key->appendChild($xml->createTextNode($record->get($idname)));
                $title->appendChild($xml->createTextNode($record->get_name()));
                $newchild->appendChild($key);
                $newchild->appendChild($title);
                $rootnode->appendChild($newchild);
             }
        }
    } else {
        die("illegal class $class");
    }
    $xml->appendChild($rootnode);
    return $xml->saveXML();
}

function get_zoph_info_array() {
    $album= get_root_album();
    $category = get_root_category();

    $size=get_human(get_photo_sizes_sum());
    return array(
        translate("number of photos") => get_count("photo"),
        translate("size of photos") => "$size",
        translate("number of photos in an album") =>
            $album->get_total_photo_count(),
        translate("number of categorized photos") =>
            $category->get_total_photo_count(),
        translate("number of people") => get_count("person"),
        translate("number of places") => get_count("place")
    );
}

?>
